import { Injectable, Logger, NotFoundException, ConflictException, ForbiddenException, BadRequestException } from '@nestjs/common';
import { randomInt, randomBytes } from 'crypto';
import { PrismaService } from '../prisma/prisma.service';
import * as bcrypt from 'bcryptjs';

export interface CreateCustomerEmployeeDto {
  email: string;
  name?: string;
  phone?: string;
  password?: string;
  permissions?: string[];
}

export interface UpdateCustomerEmployeeDto {
  name?: string;
  phone?: string;
  permissions?: string[];
  password?: string;
}

@Injectable()
export class CustomerEmployeesService {
  private readonly logger = new Logger(CustomerEmployeesService.name);

  constructor(private prismaService: PrismaService) {}

  /**
   * Create a new employee for a customer
   */
  async createCustomerEmployee(
    customerId: string,
    employeeData: CreateCustomerEmployeeDto
  ) {
    this.logger.log(`Creating employee for customer ${customerId}`, { email: employeeData.email });

    // Validate required fields
    if (!employeeData.email) {
      throw new BadRequestException('Email is required');
    }

    // Verify customer exists
    let customer;
    try {
      customer = await this.prismaService.customer.findUnique({
        where: { id: customerId },
        include: {
          tenant: {
            select: {
              id: true,
              name: true,
              subdomain: true,
              status: true,
            },
          },
        },
      });
    } catch (error: any) {
      this.logger.error('Error finding customer:', error);
      throw new NotFoundException(`Customer not found: ${error.message}`);
    }

    if (!customer) {
      this.logger.warn(`Customer not found: ${customerId}`);
      throw new NotFoundException(`Customer not found. Customer ID: ${customerId}. Please make sure you are logged in as a customer.`);
    }

    // Log customer and tenant info for debugging
    this.logger.log(`Customer found: ${customer.id}, Email: ${customer.email}, TenantId: ${customer.tenantId}, Tenant: ${customer.tenant?.name || 'N/A'}`);
    
    if (!customer.tenant) {
      this.logger.warn(`Customer ${customerId} has no associated tenant`);
      throw new BadRequestException('Customer is not associated with any store. Please contact support.');
    }
    
    if (customer.tenant.status !== 'ACTIVE') {
      this.logger.warn(`Customer ${customerId} tenant is not active: ${customer.tenant.status}`);
      throw new BadRequestException(`Store is not active. Status: ${customer.tenant.status}`);
    }

    // Check if employee already exists for this customer
    let existing;
    try {
      existing = await this.prismaService.customerEmployee.findUnique({
        where: {
          customerId_email: {
            customerId,
            email: employeeData.email.toLowerCase().trim(),
          },
        },
      });
    } catch (error: any) {
      // If table doesn't exist, provide helpful error message
      if (error.message?.includes('does not exist') || error.message?.includes('Unknown table')) {
        this.logger.error('CustomerEmployee table does not exist. Please run Prisma migration.');
        throw new BadRequestException('Database tables not found. Please run: npx prisma migrate dev --name add_customer_employees');
      }
      throw error;
    }

    if (existing) {
      throw new ConflictException('Employee with this email already exists for this customer');
    }

    // Generate password if not provided
    const isPasswordAutoGenerated = !employeeData.password;
    const password = employeeData.password || this.generateSecurePassword();
    const hashedPassword = await bcrypt.hash(password, 12);

    // Generate invite token
    const inviteToken = randomBytes(32).toString('hex');
    const inviteExpiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

    // Create employee and permissions in transaction
    const result = await this.prismaService.$transaction(async (tx: any) => {
      const employee = await tx.customerEmployee.create({
        data: {
          customerId,
          email: employeeData.email.toLowerCase().trim(),
          name: employeeData.name || employeeData.email.split('@')[0],
          phone: employeeData.phone,
          password: hashedPassword,
          isActive: true,
          mustChangePassword: isPasswordAutoGenerated, // Require password change on first login if auto-generated
          // inviteToken and inviteExpiresAt removed as they are missing in schema
        },
      });

      // Create permissions if provided
      if (employeeData.permissions && employeeData.permissions.length > 0) {
        await Promise.all(
          employeeData.permissions.map(permission =>
            tx.customerEmployeePermission.create({
              data: {
                employeeId: employee.id,
                permission,
                grantedBy: customerId,
              },
            })
          )
        );
      }

      return employee;
    });

    this.logger.log(`Created customer employee ${result.id} for customer ${customerId}`);

    return {
      ...result,
      password: isPasswordAutoGenerated ? password : undefined, // Only return if auto-generated
      inviteUrl: `invite?token=${inviteToken}`,
      inviteToken,
    };
  }

  /**
   * Get all employees for a customer
   */
  async getCustomerEmployees(customerId: string, page: number = 1, limit: number = 50) {
    try {
      const skip = (page - 1) * limit;

      // Verify customer exists
      let customer;
      try {
        customer = await this.prismaService.customer.findUnique({
          where: { id: customerId },
        });
      } catch (error: any) {
        this.logger.error('Error finding customer:', error);
        throw new NotFoundException(`Customer lookup failed: ${error.message}`);
      }

      if (!customer) {
        this.logger.warn(`Customer not found: ${customerId}`);
        throw new NotFoundException('Customer not found');
      }

      // Check if CustomerEmployee table exists
      let employees, total;
      try {
        [employees, total] = await Promise.all([
          this.prismaService.customerEmployee.findMany({
            where: { customerId },
            include: {
              permissions: {
                select: {
                  permission: true,
                  grantedAt: true,
                },
              },
            },
            skip,
            take: limit,
            orderBy: { createdAt: 'desc' },
          }),
          this.prismaService.customerEmployee.count({
            where: { customerId },
          }),
        ]);
      } catch (error: any) {
        // If table doesn't exist, return empty result
        if (error.message?.includes('does not exist') || 
            error.message?.includes('Unknown table') ||
            error.message?.includes('relation') && error.message?.includes('does not exist')) {
          this.logger.warn('CustomerEmployee table does not exist. Returning empty list.');
          return {
            data: [],
            meta: {
              page,
              limit,
              total: 0,
              totalPages: 0,
            },
          };
        }
        this.logger.error('Error fetching customer employees:', error);
        throw error;
      }

      // Remove password from response
      const employeesWithoutPassword = employees.map((emp: any) => {
        const { password, ...rest } = emp;
        return {
          ...rest,
          permissions: rest.permissions.map((p: any) => p.permission),
        };
      });

      return {
        data: employeesWithoutPassword,
        meta: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
      };
    } catch (error: any) {
      this.logger.error('Error in getCustomerEmployees:', {
        error: error.message,
        stack: error.stack,
        customerId,
      });
      
      // Re-throw known exceptions
      if (error instanceof NotFoundException) {
        throw error;
      }
      
      // For unknown errors, throw a generic error
      throw new BadRequestException(`Failed to fetch employees: ${error.message || 'Unknown error'}`);
    }
  }

  /**
   * Get a single customer employee
   */
  async getCustomerEmployee(customerId: string, employeeId: string) {
    const employee = await this.prismaService.customerEmployee.findFirst({
      where: {
        id: employeeId,
        customerId, // Ensure employee belongs to customer
      },
      include: {
        permissions: {
          select: {
            permission: true,
            grantedAt: true,
          },
        },
      },
    });

    if (!employee) {
      throw new NotFoundException('Employee not found');
    }

    const { password, ...rest } = employee;
    return {
      ...rest,
      permissions: rest.permissions.map((p: any) => p.permission),
    };
  }

  /**
   * Update customer employee permissions
   */
  async updateCustomerEmployeePermissions(
    customerId: string,
    employeeId: string,
    permissions: string[]
  ) {
    // Verify customer exists and employee belongs to customer
    const employee = await this.prismaService.customerEmployee.findFirst({
      where: {
        id: employeeId,
        customerId,
      },
    });

    if (!employee) {
      throw new NotFoundException('Employee not found');
    }

    // Update permissions in transaction
    const result = await this.prismaService.$transaction(async (tx: any) => {
      // Remove existing permissions
      await tx.customerEmployeePermission.deleteMany({
        where: { employeeId },
      });

      // Create new permissions
      if (permissions.length > 0) {
        await Promise.all(
          permissions.map(permission =>
            tx.customerEmployeePermission.create({
              data: {
                employeeId,
                permission,
                grantedBy: customerId,
              },
            })
          )
        );
      }

      return employee;
    });

    this.logger.log(`Updated permissions for customer employee ${employeeId}`);

    return {
      message: 'Permissions updated successfully',
      permissions,
    };
  }

  /**
   * Update a customer employee
   */
  async updateCustomerEmployee(
    customerId: string,
    employeeId: string,
    updateData: UpdateCustomerEmployeeDto
  ) {
    // Verify customer exists and employee belongs to customer
    const employee = await this.prismaService.customerEmployee.findFirst({
      where: {
        id: employeeId,
        customerId,
      },
    });

    if (!employee) {
      throw new NotFoundException('Employee not found');
    }

    // Prepare update data
    const dataToUpdate: any = {};
    if (updateData.name) dataToUpdate.name = updateData.name;
    if (updateData.phone) dataToUpdate.phone = updateData.phone;
    // Only update password if provided and not empty
    if (updateData.password && updateData.password.trim()) {
      // Use 12 rounds for bcrypt
      const salt = await bcrypt.genSalt(12);
      dataToUpdate.password = await bcrypt.hash(updateData.password, salt);
    }

    // Update employee and permissions in transaction
    const result = await this.prismaService.$transaction(async (tx: any) => {
      // Update employee details if any
      let updatedEmployee = employee;
      if (Object.keys(dataToUpdate).length > 0) {
        updatedEmployee = await tx.customerEmployee.update({
          where: { id: employeeId },
          data: dataToUpdate,
        });
      }

      // Update permissions if provided
      if (updateData.permissions) {
        // Remove existing permissions
        await tx.customerEmployeePermission.deleteMany({
          where: { employeeId },
        });

        // Create new permissions
        if (updateData.permissions.length > 0) {
          await Promise.all(
            updateData.permissions.map(permission =>
              tx.customerEmployeePermission.create({
                data: {
                  employeeId,
                  permission,
                  grantedBy: customerId,
                },
              })
            )
          );
        }
      }

      return updatedEmployee;
    });

    this.logger.log(`Updated customer employee ${employeeId}`);

    const { password, ...rest } = result;
    return {
      ...rest,
      permissions: updateData.permissions,
    };
  }

  /**
   * Delete a customer employee
   */
  async deleteCustomerEmployee(customerId: string, employeeId: string) {
    const employee = await this.prismaService.customerEmployee.findFirst({
      where: {
        id: employeeId,
        customerId,
      },
    });

    if (!employee) {
      throw new NotFoundException('Employee not found');
    }

    await this.prismaService.customerEmployee.delete({
      where: { id: employeeId },
    });

    this.logger.log(`Deleted customer employee ${employeeId}`);
    return { message: 'Employee deleted successfully' };
  }

  /**
   * Get available store-level permissions (different from platform permissions)
   */
  getAvailableStorePermissions(): string[] {
    return [
      // Store pages access
      'store:home:view',
      'store:products:view',
      'store:products:create',
      'store:products:edit',
      'store:products:delete',
      'store:orders:view',
      'store:orders:create',
      'store:orders:edit',
      'store:orders:cancel',
      'store:customers:view',
      'store:customers:edit',
      'store:cart:view',
      'store:cart:manage',
      'store:checkout:access',
      'store:wallet:view',
      'store:wallet:recharge',
      'store:profile:view',
      'store:profile:edit',
    ];
  }

  /**
   * Add balance to employee
   */
  async addBalance(customerId: string, employeeId: string, amount: number) {
    // Verify ownership
    await this.getCustomerEmployee(customerId, employeeId);
    
    return this.prismaService.customerEmployee.update({
      where: { id: employeeId },
      data: {
        balance: {
          increment: amount
        }
      }
    });
  }

  /**
   * Change password for customer employee (used for first login and regular password changes)
   */
  async changePassword(employeeId: string, currentPassword: string, newPassword: string): Promise<{ message: string }> {
    try {
      // Get employee
      const employee = await this.prismaService.customerEmployee.findUnique({
        where: { id: employeeId },
      });

      if (!employee) {
        throw new NotFoundException('Employee not found');
      }

      // Verify current password (if mustChangePassword is false, require current password)
      // If mustChangePassword is true, allow change without current password (first login)
      if (!employee.mustChangePassword) {
        const isCurrentPasswordValid = await bcrypt.compare(currentPassword, employee.password);
        if (!isCurrentPasswordValid) {
          throw new BadRequestException('Current password is incorrect');
        }
      } else {
        // For first login, verify the temporary password
        const isTemporaryPasswordValid = await bcrypt.compare(currentPassword, employee.password);
        if (!isTemporaryPasswordValid) {
          throw new BadRequestException('Temporary password is incorrect');
        }
      }

      // Hash new password
      const hashedPassword = await bcrypt.hash(newPassword, 12);

      // Update password and clear mustChangePassword flag
      await this.prismaService.customerEmployee.update({
        where: { id: employeeId },
        data: {
          password: hashedPassword,
          mustChangePassword: false, // Clear the flag after password change
        },
      });

      this.logger.log(`✅ Password changed successfully for employee: ${employee.email}`);
      return { message: 'Password changed successfully' };
    } catch (error: any) {
      this.logger.error(`❌ Password change failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Generate secure random password
   */
  private generateSecurePassword(): string {
    const length = 12;
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
    let password = '';
    const charsetLength = charset.length;
    for (let i = 0; i < length; i++) {
      const randomIndex = randomInt(0, charsetLength);
      password += charset.charAt(randomIndex);
    }
    return password;
  }
}

