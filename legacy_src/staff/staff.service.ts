import { Injectable, ForbiddenException, NotFoundException, ConflictException, BadRequestException, Logger } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { EmailService } from '../email/email.service';
import * as bcrypt from 'bcryptjs';
import { randomInt } from 'crypto';

export interface CreateStaffDto {
  email: string;
  password?: string;
  name?: string;
  phone?: string;
  role?: string;
  permissions: string[];
  assignedCustomers?: string[];
}

export interface UpdateStaffDto {
  email?: string;
  name?: string;
  permissions?: string[];
}

@Injectable()
export class StaffService {
  private readonly logger = new Logger(StaffService.name);

  constructor(
    private prismaService: PrismaService,
    private emailService: EmailService,
  ) {}

  /**
   * Generate a secure random password for staff accounts
   */
  private generateSecurePassword(): string {
    // Generate a 12-character password with letters and numbers
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let password = '';
    const charsLength = chars.length;
    for (let i = 0; i < 12; i++) {
      const randomIndex = randomInt(0, charsLength);
      password += chars.charAt(randomIndex);
    }
    return password;
  }

  /**
   * Create a new staff user
   */
  async createStaff(tenantId: string, creatingUserId: string, staffData: CreateStaffDto) {
    // Verify creating user has permission
    // For SUPER_ADMIN, allow regardless of tenantId
    // For SHOP_OWNER, must belong to the same tenant
    const creatingUser = await this.prismaService.user.findUnique({
      where: { id: creatingUserId },
    });

    if (!creatingUser) {
      throw new ForbiddenException('User not found');
    }

    // Check if user has permission to create staff
    const isSuperAdmin = creatingUser.role === 'SUPER_ADMIN';
    const isShopOwner = creatingUser.role === 'SHOP_OWNER' && creatingUser.tenantId === tenantId;

    if (!isSuperAdmin && !isShopOwner) {
      throw new ForbiddenException('Insufficient permissions to create staff users. Only shop owners and super admins can create staff users.');
    }

    // Check if user already exists
    const existingUser = await this.prismaService.user.findUnique({
      where: { email: staffData.email },
    });

    if (existingUser) {
      throw new ConflictException('User already exists');
    }

    // Generate password if not provided (use a more secure random password)
    const isPasswordAutoGenerated = !staffData.password;
    const password = staffData.password || this.generateSecurePassword();
    const hashedPassword = await bcrypt.hash(password, 12);

    // Prepare metadata for employee info
    const employeeMetadata: any = {};
    if (staffData.phone) {
      employeeMetadata.phone = staffData.phone;
    }
    if (staffData.role) {
      employeeMetadata.role = staffData.role;
    }
    if (staffData.assignedCustomers && staffData.assignedCustomers.length > 0) {
      employeeMetadata.assignedCustomers = staffData.assignedCustomers;
    }

    // Create staff user and permissions in transaction
    const result = await this.prismaService.$transaction(async (tx: any) => {
      // Create user as staff
      // Staff created by admins are trusted, so emailVerified=true
      // Set mustChangePassword=true for auto-generated passwords (first login)
      const user = await tx.user.create({
        data: {
          email: staffData.email,
          password: hashedPassword,
          role: 'STAFF',
          tenantId,
          name: staffData.name || staffData.email.split('@')[0],
          emailVerified: true, // Staff created by admins are automatically verified
          mustChangePassword: isPasswordAutoGenerated, // Require password change on first login if auto-generated
          // Store employee metadata in a special permission or we'll need to add metadata field
          // For now, we'll store it in a special permission
        },
      });

      // Store employee metadata as special permission entries
      if (staffData.phone) {
        await tx.staffPermission.create({
          data: {
            userId: user.id,
            tenantId,
            permission: `employee:phone:${staffData.phone}`,
            grantedBy: creatingUserId,
          },
        });
      }
      if (staffData.role) {
        await tx.staffPermission.create({
          data: {
            userId: user.id,
            tenantId,
            permission: `employee:role:${staffData.role}`,
            grantedBy: creatingUserId,
          },
        });
      }
      if (staffData.assignedCustomers && staffData.assignedCustomers.length > 0) {
        await tx.staffPermission.create({
          data: {
            userId: user.id,
            tenantId,
            permission: `employee:customers:${JSON.stringify(staffData.assignedCustomers)}`,
            grantedBy: creatingUserId,
          },
        });
      }

      // Create staff permissions
      const permissions = await Promise.all(
        staffData.permissions.map(permission =>
          tx.staffPermission.create({
            data: {
              userId: user.id,
              tenantId,
              permission,
              grantedBy: creatingUserId,
            },
          })
        )
      );

      return { user, permissions };
    });

    // Log staff creation
    await this.logAuditEvent(
      creatingUserId,
      tenantId,
      'STAFF_CREATED',
      result.user.id,
      'user',
      undefined,
      { permissions: staffData.permissions },
      { staffEmail: staffData.email }
    );

    this.logger.log(`✅ Staff user created: ${staffData.email} by user: ${creatingUserId}`);

    // Return the password only if it was auto-generated (so admin can share it with employee)
    const response: any = {
      id: result.user.id,
      email: result.user.email,
      permissions: staffData.permissions,
      createdAt: result.user.createdAt,
    };

    // Include password in response if it was auto-generated
    if (isPasswordAutoGenerated) {
      response.password = password;
      this.logger.log(`⚠️ Auto-generated password for staff ${staffData.email}. Admin should share this with the employee.`);
    }

    return response;
  }

  /**
   * Get all staff users for a tenant
   */
  async getStaffUsers(tenantId: string, page: number = 1, limit: number = 50) {
    const skip = (page - 1) * limit;

    const [staffUsers, total] = await Promise.all([
      this.prismaService.user.findMany({
        where: {
          tenantId,
          role: 'STAFF',
        },
        select: {
          id: true,
          email: true,
          name: true,
          createdAt: true,
          updatedAt: true,
          staffPermissions: {
            select: {
              permission: true,
              grantedAt: true,
              grantedBy: true,
            },
          },
        },
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
      }),
      this.prismaService.user.count({
        where: {
          tenantId,
          role: 'STAFF',
        },
      }),
    ]);

    // Parse employee metadata from permissions
    const staffUsersWithMetadata = staffUsers.map((user: any) => {
      const phonePermission = user.staffPermissions.find((p: any) => p.permission.startsWith('employee:phone:'));
      const rolePermission = user.staffPermissions.find((p: any) => p.permission.startsWith('employee:role:'));
      const customersPermission = user.staffPermissions.find((p: any) => p.permission.startsWith('employee:customers:'));

      return {
        ...user,
        phone: phonePermission ? phonePermission.permission.replace('employee:phone:', '') : null,
        role: rolePermission ? rolePermission.permission.replace('employee:role:', '') : null,
        assignedCustomers: customersPermission ? JSON.parse(customersPermission.permission.replace('employee:customers:', '')) : [],
      };
    });

    return {
      data: staffUsersWithMetadata,
      meta: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * Get a specific staff user
   */
  async getStaffUser(tenantId: string, staffUserId: string) {
    const staffUser = await this.prismaService.user.findFirst({
      where: {
        id: staffUserId,
        tenantId,
        role: 'STAFF',
      },
        select: {
          id: true,
          email: true,
          name: true,
          createdAt: true,
          updatedAt: true,
          staffPermissions: {
            select: {
              permission: true,
              grantedAt: true,
              grantedBy: true,
            },
          },
        },
    });

    if (!staffUser) {
      throw new NotFoundException('Staff user not found');
    }

    // Parse employee metadata from permissions
    const phonePermission = staffUser.staffPermissions.find((p: any) => p.permission.startsWith('employee:phone:'));
    const rolePermission = staffUser.staffPermissions.find((p: any) => p.permission.startsWith('employee:role:'));
    const customersPermission = staffUser.staffPermissions.find((p: any) => p.permission.startsWith('employee:customers:'));

    return {
      ...staffUser,
      phone: phonePermission ? phonePermission.permission.replace('employee:phone:', '') : null,
      role: rolePermission ? rolePermission.permission.replace('employee:role:', '') : null,
      assignedCustomers: customersPermission ? JSON.parse(customersPermission.permission.replace('employee:customers:', '')) : [],
    };
  }

  /**
   * Update staff user permissions
   */
  async updateStaffPermissions(
    tenantId: string, 
    updatingUserId: string, 
    staffUserId: string, 
    permissions: string[]
  ) {
    // Verify updating user has permission
    // For SUPER_ADMIN, allow regardless of tenantId
    // For SHOP_OWNER, must belong to the same tenant
    const updatingUser = await this.prismaService.user.findUnique({
      where: { id: updatingUserId },
    });

    if (!updatingUser) {
      this.logger.error(`User not found: ${updatingUserId}`);
      throw new ForbiddenException('User not found');
    }

    this.logger.log(`Updating permissions - User: ${updatingUserId} (${updatingUser.email}), Role: ${updatingUser.role}, User TenantId: ${updatingUser.tenantId}, Target TenantId: ${tenantId}`);

    // Check if user has permission to update staff permissions
    const isSuperAdmin = updatingUser.role === 'SUPER_ADMIN';
    const isCustomer = updatingUser.role === 'CUSTOMER';
    
    // Normalize tenantIds for comparison (convert null/undefined to empty string, trim whitespace)
    const userTenantId = updatingUser.tenantId ? String(updatingUser.tenantId).trim() : '';
    const targetTenantId = tenantId ? String(tenantId).trim() : '';
    
    // For SHOP_OWNER, check multiple scenarios:
    // 1. Direct tenantId match
    // 2. Both are empty/null (both users without tenant)
    // 3. If tenantIds don't match, verify staff user belongs to user's tenant (fallback check)
    let tenantIdMatches = userTenantId === targetTenantId || (userTenantId === '' && targetTenantId === '');
    let isShopOwner = updatingUser.role === 'SHOP_OWNER';
    
    // For CUSTOMER, they can manage staff in their tenant
    // Customers are identified by having a customer record in the Customer table
    // We need to check if the updating user is a customer and if they belong to the same tenant as the staff
    let isCustomerAuthorized = false;
    if (isCustomer) {
      // Check if customer exists and belongs to the same tenant
      const customer = await this.prismaService.customer.findFirst({
        where: {
          email: updatingUser.email,
          tenantId: targetTenantId || userTenantId,
        },
      });
      
      if (customer) {
        // Customer exists in the tenant - they can manage staff in their tenant
        isCustomerAuthorized = true;
        tenantIdMatches = true; // Customer and staff must be in same tenant
        this.logger.log(`Customer ${updatingUser.email} authorized to manage staff in tenant ${targetTenantId || userTenantId}`);
      }
    }
    
    // If tenantId doesn't match but user is SHOP_OWNER, verify they own the tenant that the staff user belongs to
    if (!tenantIdMatches && isShopOwner && updatingUser.role === 'SHOP_OWNER') {
      // Check if staff user exists and get their tenantId
      const staffCheck = await this.prismaService.user.findUnique({
        where: { id: staffUserId },
        select: { tenantId: true, role: true }
      });
      
      if (staffCheck && staffCheck.role === 'STAFF') {
        const staffTenantId = staffCheck.tenantId ? String(staffCheck.tenantId).trim() : '';
        // If staff belongs to user's tenant, allow it
        if (staffTenantId === userTenantId || (staffTenantId === '' && userTenantId === '')) {
          tenantIdMatches = true;
          this.logger.log(`TenantId mismatch resolved - Staff belongs to user's tenant`);
        } else if (staffTenantId) {
          // Check if user is owner of the staff's tenant via user_tenants table
          try {
            const userTenant = await this.prismaService.userTenant.findFirst({
              where: {
                userId: updatingUserId,
                tenantId: staffTenantId,
                isOwner: true
              }
            });
            if (userTenant) {
              tenantIdMatches = true;
              this.logger.log(`TenantId mismatch resolved - User is owner of staff's tenant via user_tenants`);
            }
          } catch (error) {
            this.logger.warn(`Could not check user_tenants: ${error instanceof Error ? error.message : 'Unknown error'}`);
          }
        }
      }
    }
    
    isShopOwner = isShopOwner && tenantIdMatches;
    isCustomerAuthorized = isCustomerAuthorized && tenantIdMatches;

    this.logger.log(`Permission check - isSuperAdmin: ${isSuperAdmin}, isShopOwner: ${isShopOwner}, isCustomerAuthorized: ${isCustomerAuthorized}, userTenantId: "${userTenantId}", targetTenantId: "${targetTenantId}", tenantIdMatches: ${tenantIdMatches}`);

    if (!isSuperAdmin && !isShopOwner && !isCustomerAuthorized) {
      this.logger.warn(`Permission denied - User: ${updatingUserId}, Role: ${updatingUser.role}, User TenantId: "${userTenantId}", Target TenantId: "${targetTenantId}"`);
      throw new ForbiddenException(`Insufficient permissions to update staff permissions. Only shop owners, customers, and super admins can update staff permissions. Your role: ${updatingUser.role}, Your tenantId: "${userTenantId}", Target tenantId: "${targetTenantId}"`);
    }

    // Verify staff user exists and belongs to tenant
    // For SUPER_ADMIN, allow updating any staff user
    // For SHOP_OWNER, staff must belong to the same tenant
    const staffUserWhere: any = {
      id: staffUserId,
      role: 'STAFF'
    };
    
    // Only add tenantId filter if tenantId is provided (not empty/null)
    // For SUPER_ADMIN, we can update any staff user, so don't filter by tenantId
    // For SHOP_OWNER, we must filter by tenantId to ensure they can only update their own staff
    if (!isSuperAdmin && targetTenantId && targetTenantId !== '') {
      staffUserWhere.tenantId = targetTenantId;
    } else if (!isSuperAdmin && (!targetTenantId || targetTenantId === '')) {
      // SHOP_OWNER with no tenantId - this shouldn't happen, but handle gracefully
      this.logger.warn(`SHOP_OWNER ${updatingUserId} has no tenantId - cannot determine which staff to update`);
    }
    
    const staffUser = await this.prismaService.user.findFirst({
      where: staffUserWhere,
    });
    
    this.logger.log(`Staff user lookup - staffUserId: ${staffUserId}, where: ${JSON.stringify(staffUserWhere)}, found: ${!!staffUser}`);

    if (!staffUser) {
      throw new NotFoundException('Staff user not found');
    }

    // Update permissions in transaction
    const result = await this.prismaService.$transaction(async (tx: { staffPermission: { deleteMany: (arg0: { where: { userId: string; tenantId: string; }; }) => any; create: (arg0: { data: { userId: string; tenantId: string; permission: string; grantedBy: string; }; }) => any; }; }) => {
      // Remove existing permissions
      await tx.staffPermission.deleteMany({
        where: {
          userId: staffUserId,
          tenantId,
        },
      });

      // Create new permissions
      const newPermissions = await Promise.all(
        permissions.map(permission =>
          tx.staffPermission.create({
            data: {
              userId: staffUserId,
              tenantId,
              permission,
              grantedBy: updatingUserId,
            },
          })
        )
      );

      return newPermissions;
    });

    // Log permission update
    await this.logAuditEvent(
      updatingUserId,
      tenantId,
      'STAFF_PERMISSIONS_UPDATED',
      staffUserId,
      'user',
      undefined,
      { permissions },
      { staffEmail: staffUser.email }
    );

    this.logger.log(`✅ Staff permissions updated for user: ${staffUser.email} by user: ${updatingUserId}`);

    return {
      message: 'Staff permissions updated successfully',
      permissions: result.map((p: { permission: any; }) => p.permission),
    };
  }

  /**
   * Delete a staff user
   */
  async deleteStaffUser(tenantId: string, deletingUserId: string, staffUserId: string) {
    // Verify deleting user has permission
    // For SUPER_ADMIN, allow regardless of tenantId
    // For SHOP_OWNER, must belong to the same tenant
    const deletingUser = await this.prismaService.user.findUnique({
      where: { id: deletingUserId },
    });

    if (!deletingUser) {
      throw new ForbiddenException('User not found');
    }

    // Check if user has permission to delete staff
    const isSuperAdmin = deletingUser.role === 'SUPER_ADMIN';
    const isShopOwner = deletingUser.role === 'SHOP_OWNER' && deletingUser.tenantId === tenantId;

    if (!isSuperAdmin && !isShopOwner) {
      throw new ForbiddenException('Insufficient permissions to delete staff users. Only shop owners and super admins can delete staff users.');
    }

    // Verify staff user exists and belongs to tenant
    const staffUser = await this.prismaService.user.findFirst({
      where: { 
        id: staffUserId,
        tenantId,
        role: 'STAFF'
      },
    });

    if (!staffUser) {
      throw new NotFoundException('Staff user not found');
    }

    // Prevent self-deletion
    if (staffUserId === deletingUserId) {
      throw new BadRequestException('Cannot delete your own account');
    }

    // Delete staff user and related data in transaction
    await this.prismaService.$transaction(async (tx: { staffPermission: { deleteMany: (arg0: { where: { userId: string; tenantId: string; }; }) => any; }; refreshToken: { deleteMany: (arg0: { where: { userId: string; }; }) => any; }; user: { delete: (arg0: { where: { id: string; }; }) => any; }; }) => {
      // Delete staff permissions
      await tx.staffPermission.deleteMany({
        where: {
          userId: staffUserId,
          tenantId,
        },
      });

      // Delete refresh tokens
      await tx.refreshToken.deleteMany({
        where: {
          userId: staffUserId,
        },
      });

      // Delete the user
      await tx.user.delete({
        where: {
          id: staffUserId,
        },
      });
    });

    // Log staff deletion
    await this.logAuditEvent(
      deletingUserId,
      tenantId,
      'STAFF_DELETED',
      staffUserId,
      'user',
      undefined,
      undefined,
      { staffEmail: staffUser.email }
    );

    this.logger.log(`✅ Staff user deleted: ${staffUser.email} by user: ${deletingUserId}`);

    return {
      message: 'Staff user deleted successfully',
    };
  }

  /**
   * Get available permissions
   */
  getAvailablePermissions(): string[] {
    return [
      // Product permissions
      'product:create',
      'product:read', 
      'product:update',
      'product:delete',
      'product:manage',

      // Order permissions
      'order:create',
      'order:read',
      'order:update',
      'order:delete',
      'order:manage',

      // Customer permissions
      'customer:create',
      'customer:read',
      'customer:update',
      'customer:delete',
      'customer:manage',

      // Inventory permissions
      'inventory:read',
      'inventory:update',
      'inventory:manage',

      // Analytics permissions
      'analytics:read',
      'analytics:manage',

      // Settings permissions
      'settings:read',
      'settings:update',
    ];
  }

  /**
   * Check if a staff user has specific permission
   */
  async hasPermission(userId: string, tenantId: string, permission: string): Promise<boolean> {
    const user = await this.prismaService.user.findFirst({
      where: { id: userId, tenantId },
    });

    if (!user) {
      return false;
    }

    // Super admins and shop owners have all permissions
    if (user.role === 'SUPER_ADMIN' || user.role === 'SHOP_OWNER') {
      return true;
    }

    // Check specific permission for staff
    const hasPermission = await this.prismaService.staffPermission.findFirst({
      where: {
        userId,
        tenantId,
        permission,
      },
    });

    return !!hasPermission;
  }

  /**
   * Get staff user permissions
   */
  async getUserPermissions(userId: string, tenantId: string): Promise<string[]> {
    const permissions = await this.prismaService.staffPermission.findMany({
      where: {
        userId,
        tenantId,
      },
      select: { permission: true },
    });

    return permissions.map((p: { permission: any; }) => p.permission);
  }

  /**
   * Send credentials to staff user
   */
  async sendCredentials(tenantId: string, email: string, password?: string, inviteUrl?: string) {
    const platformName = process.env.PLATFORM_NAME || 'Koun';
    
    // Fetch tenant name for branding
    const tenant = await this.prismaService.tenant.findUnique({
      where: { id: tenantId },
      select: { name: true }
    });
    const brandName = tenant?.name || platformName;

    let html = '';
    if (inviteUrl) {
      // For localhost testing, handle subdomain if needed (done on frontend usually, but here for robustness)
      const formattedInviteUrl = inviteUrl;
      
      html = `
        <div dir="rtl" style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; border: 1px solid #eee; padding: 20px; border-radius: 10px;">
          <h2 style="color: #3b82f6;">مرحباً بك في ${brandName}</h2>
          <p>تمت دعوتك للانضمام إلى فريق العمل.</p>
          <p>يرجى الضغط على الزر التالي لإكمال تسجيل حسابك وتعيين كلمة المرور:</p>
          <div style="text-align: center; margin: 30px 0;">
            <a href="${formattedInviteUrl}" style="background: #3b82f6; color: white; padding: 12px 25px; text-decoration: none; border-radius: 5px; font-weight: bold; display: inline-block;">إكمال التسجيل</a>
          </div>
          <p style="font-size: 12px; color: #666;">أو انسخ الرابط التالي وضعه في المتصفح:</p>
          <p style="font-size: 12px; color: #666; word-break: break-all;">${formattedInviteUrl}</p>
          <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">
          <p style="font-size: 12px; color: #999;">هذا الرابط مخصص لك فقط، يرجى عدم مشاركته مع الآخرين.</p>
        </div>
      `;
    } else if (password) {
      const loginUrl = `${process.env.FRONTEND_URL || 'https://kawn.com'}/auth/login`;
      
      html = `
        <div dir="rtl" style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; border: 1px solid #eee; padding: 20px; border-radius: 10px;">
          <h2 style="color: #3b82f6;">مرحباً بك في ${brandName}</h2>
          <p>تم إنشاء حساب الموظف الخاص بك بنجاح. يمكنك الآن تسجيل الدخول باستخدام البيانات التالية:</p>
          <div style="background: #f9fafb; padding: 15px; border-radius: 5px; margin: 20px 0;">
            <p style="margin: 5px 0;"><strong>البريد الإلكتروني:</strong> ${email}</p>
            <p style="margin: 5px 0;"><strong>كلمة المرور المؤقتة:</strong> <span style="font-family: monospace; font-size: 18px; color: #ef4444;">${password}</span></p>
          </div>
          <p>يرجى تسجيل الدخول وتغيير كلمة المرور الخاصة بك عند الدخول لأول مرة.</p>
          <div style="text-align: center; margin: 30px 0;">
            <a href="${loginUrl}" style="background: #3b82f6; color: white; padding: 12px 25px; text-decoration: none; border-radius: 5px; font-weight: bold; display: inline-block;">تسجيل الدخول</a>
          </div>
          <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">
          <p style="font-size: 12px; color: #999;">إذا لم تكن تتوقع هذا البريد، يرجى تجاهله.</p>
        </div>
      `;
    }

    await this.emailService.sendEmail(
      email,
      `بيانات دخول الموظف - ${brandName}`,
      html,
      undefined,
      brandName,
      tenantId
    );

    return { success: true };
  }

  private async logAuditEvent(
    userId: string,
    tenantId: string,
    action: string,
    resourceId?: string,
    resourceType?: string,
    oldValues?: any,
    newValues?: any,
    metadata?: any,
  ): Promise<void> {
    try {
      await this.prismaService.auditLog.create({
        data: {
          userId,
          tenantId,
          action,
          resourceId,
          resourceType,
          oldValues,
          newValues,
          metadata,
        },
      });
    } catch (error) {
      this.logger.error('Failed to log audit event:', error);
    }
  }
}